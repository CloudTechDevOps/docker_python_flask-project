server {
    listen 80;
    server_name 98.81.160.29;

    location / {
        proxy_pass http://127.0.0.1:5000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}




==============================================================

1️.  Host Header (proxy_set_header Host $host;)

Required? Usually yes

Reason: Ensures Flask knows which domain the client requested.

Without it, Flask may generate URLs incorrectly or use 127.0.0.1:5000 as the host.

2️. X-Real-IP (proxy_set_header X-Real-IP $remote_addr;)

Required? Yes if you want accurate client IPs in logs or for IP-based logic.

Without it, Flask sees all requests as coming from 127.0.0.1 (Nginx).

3️.  X-Forwarded-For (proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;)

Required? Recommended for apps behind multiple proxies or load balancers.

Keeps a chain of client IPs.

Without it, you lose the real client IP if there’s another proxy before Nginx.

4️.  X-Forwarded-Proto (proxy_set_header X-Forwarded-Proto $scheme;)

Required? Recommended if your app needs to know whether the request was HTTP or HTTPS.

Useful for generating proper redirects or absolute URLs in Flask.


=========================== nginx load balncer ========

upstream flask_app {
    # Round-robin load balancing (default)
    server 10.0.1.101:5000;
    server 10.0.1.102:5000;
}

server {
    listen 80;
    server_name yourdomain.com;  # or public IP

    location / {
        proxy_pass http://flask_app;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /static/ {
        # Optional: serve static files from one backend
        proxy_pass http://flask_app/static/;
    }
}

#upstream flask_app defines your backends.

#Default method is round-robin, so requests alternate: backend1 → backend2 → backend1 …

#proxy_set_header ensures your Flask app sees the real client IP and original host.


#Optional: Advanced Round-Robin Settings

You can add:

#upstream flask_app {
    server 10.0.1.101:5000 weight=2;  # 2x traffic goes here
    server 10.0.1.102:5000;
}

=============================== Path based Example  ============================

# Upstream for app1
upstream app1_backend {
    server 10.0.1.101:5000;
}

# Upstream for app2
upstream app2_backend {
    server 10.0.1.102:5000;
}

server {
    listen 80;
    server_name yourdomain.com;  # or public IP

    # Route /app1
    location /app1/ {
        proxy_pass http://app1_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Route /app2
    location /app2/ {
        proxy_pass http://app2_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Optional: serve static files
    location /static/ {
        proxy_pass http://app1_backend/static/;
    }
}

